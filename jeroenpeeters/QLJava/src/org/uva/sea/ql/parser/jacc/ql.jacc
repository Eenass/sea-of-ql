%package org.uva.sea.ql.parser.jacc
%class QLParser
%interface QLTokens
%semantic org.uva.sea.ql.ast.ASTNode 
%start top

%token FORM
%token <Int> INT
%token <Text> TEXT
%token <Ident> IDENT
%token '*' '/' '+' '-' OR AND NEQ EQ '<' LEQ '>' GEQ '!'
%token '(' ')' '{' '}' ':' '"'
%token IF
%token <DataType> BOOLEAN INTEGER MONEY TEXT

%left OR
%left AND
%left '>' '<' GEQ LEQ NEQ EQ
%left '+' '-'
%left '*' '/'
%left UMIN UPLUS UNOT

%type <Form> frm
%type <CompoundStatement> cmpnd_stmnt
%type <Question> quest
%type <Expr> expr stmnt
%type <If> if_stmnt
%type <DataType> data_type

%{
import org.uva.sea.ql.ast.*;
import org.uva.sea.ql.ast.literals.*;
%}

%%

 top 			: frm	 					{ result = $1; }
 				| expr						{ result = $1; }
 				| quest						{ result = $1; }
     			; 
 
 frm    		: FORM IDENT '{' cmpnd_stmnt '}'	{ $$ = new Form($2, $4); }
 				;
 				
 cmpnd_stmnt 	: stmnt					{ $$ = new CompoundStatement($1); }
 				| cmpnd_stmnt stmnt		{ $1.add($2); $$ = $1; }
 				;
 				
 stmnt			: if_stmnt				{ $$ = $1; }
 				| quest					{ $$ = $1; }
 				;

 if_stmnt		: IF '(' expr ')' '{' cmpnd_stmnt '}' 	{ $$ = new If($3, $6); } 				
				;
				
 expr	 		: '+' expr	%prec UPLUS { $$ = new Pos($2); }
				| '-' expr	%prec UMIN  { $$ = new Neg($2); }
				| '!' expr %prec UNOT  	{ $$ = new Not($2); }
				| expr '*' expr			{ $$ = new Mul($1, $3); }
				| expr '/' expr 		{ $$ = new Div($1, $3); }
				| expr '+' expr			{ $$ = new Add($1, $3); }
				| expr '-' expr			{ $$ = new Sub($1, $3); }
				| expr EQ expr		    { $$ = new Eq($1, $3); }
				| expr NEQ expr			{ $$ = new NEq($1, $3); }
				| expr '>' expr			{ $$ = new GT($1, $3); }
				| expr '<' expr			{ $$ = new LT($1, $3); }
				| expr GEQ expr			{ $$ = new GEq($1, $3); }
				| expr LEQ expr			{ $$ = new LEq($1, $3); }
				| expr AND expr	    	{ $$ = new And($1, $3); }
			    | expr OR expr  		{ $$ = new Or($1, $3); }
				| INT					{ $$ = $1; }
				| IDENT         		{ $$ = $1; }
				| '(' expr ')'			{ $$ = $2; }
				;
			 	
 quest   		: IDENT ':' TEXT data_type 	{ $$ = new Question($1, $3, $4); }
         		;
         		
 data_type		: BOOLEAN 				{ $$ = DataType.BOOLEAN; }
 				| INTEGER 				{ $$ = DataType.INTEGER; }
 				| MONEY 				{ $$ = DataType.MONEY; }
 				| TEXT					{ $$ = DataType.TEXT; }
 				;
		 
%%

private QLLexer lexer; 

private Expr result;

public Expr getResult() {
  return result;
}

public QLParser(QLLexer lexer) { 
  this.lexer = lexer; 
}

private void yyerror(String msg) { 
  System.err.println(msg); 
}