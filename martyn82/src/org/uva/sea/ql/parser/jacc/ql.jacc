%package org.uva.sea.ql.parser.jacc
%class QLParser
%interface QLTokens
%semantic org.uva.sea.ql.ast.INode 
%start start

%token <org.uva.sea.ql.ast.type.Bool> BOOLEAN
%token <org.uva.sea.ql.ast.type.Money> MONEY
%token <org.uva.sea.ql.ast.type.Int> INTEGER
%token <org.uva.sea.ql.ast.type.Str> STRING
%token <org.uva.sea.ql.ast.expression.value.Bool> BOOL
%token <org.uva.sea.ql.ast.expression.value.Money> MON
%token <org.uva.sea.ql.ast.expression.value.Int> INT
%token <org.uva.sea.ql.ast.expression.value.Str> STR
%token <org.uva.sea.ql.ast.expression.Ident> IDENT
%token '^' '*' '/' '+' '-' OR AND NEQ EQ '<' LEQ '>' GEQ '!'
%token '(' ')' '{' '}'
%token ';' ':'
%token IF ELSE FORM

%left OR
%left AND
%left '>' '<' GEQ LEQ NEQ EQ
%left '+' '-'
%left '*' '/'
%left '^'
%left UMIN UPLUS UNOT

%type <Assignment> assignment
%type <Expression> expression
%type <FormDeclaration> form
%type <IfThenElse> ifblock
%type <Statement> statement
%type <Statements> formbody ifbody ifelse statements
%type <Type> type
%type <VarDeclaration> vardeclaration

%{
import org.uva.sea.ql.ast.*;
import org.uva.sea.ql.ast.expression.*;
import org.uva.sea.ql.ast.statement.*;
import org.uva.sea.ql.ast.type.Type;
%}

%%

 start          : node  { result = $1; }
                ;

 node           : form
                | statement
                | expression
                ;

 form           : FORM IDENT '{' formbody '}'      { $$ = new FormDeclaration( $2, $4 ); }
                ;

 formbody       : statements
                ;

 statements     : statement statements             { $$ = new Statements( $1, $2 ); }
                | statement                        { $$ = new Statements( $1 ); }
                ;

 statement      : question
                | blockstatement
                | vardeclaration
                | assignment
                ;

 question       : STR vardeclaration               { $$ = new QuestionDeclaration( $1, $2 ); }
                | STR assignment                   { $$ = new QuestionDeclaration( $1, $2 ); }
                ;

 blockstatement : ifblock
                ;

 ifblock        : IF '(' expression ')' '{' ifbody '}' ifelse  { $$ = new IfThenElse( $3, $6, $8 ); }
                | IF '(' expression ')' '{' ifbody '}'         { $$ = new IfThenElse( $3, $6 ); }
                | IF '(' expression ')' '{' '}' ifelse         { $$ = new IfThenElse( $3, null, $7 ); }
                | IF '(' expression ')' '{' '}'                { $$ = new IfThenElse( $3 ); }
                ;
                
 ifelse         : ELSE ifblock                     { $$ = new Statements( $2 ); }
                | ELSE '{' ifbody '}'              { $$ = $3; }
                | ELSE '{' '}'                     { $$ = null; }
                ;

 ifbody         : formbody
                ;

 vardeclaration : IDENT ':' type                   { $$ = new VarDeclaration( $1, $3 ); }
                ;

 assignment     : IDENT '=' expression             { $$ = new Assignment( $1, $3 ); }
                ;

 comparison     : expression EQ expression         { $$ = new Eq( $1, $3 ); }
                | expression NEQ expression        { $$ = new NEq( $1, $3 ); }
                | expression '>' expression        { $$ = new GT( $1, $3 ); }
                | expression '<' expression        { $$ = new LT( $1, $3 ); }
                | expression GEQ expression        { $$ = new GEq( $1, $3 ); }
                | expression LEQ expression        { $$ = new LEq( $1, $3 ); }
                ;

 arithmetic     : expression '*' expression        { $$ = new Mul( $1, $3 ); }
                | expression '/' expression        { $$ = new Div( $1, $3 ); }
                | expression '+' expression        { $$ = new Add( $1, $3 ); }
                | expression '-' expression        { $$ = new Sub( $1, $3 ); }
                | expression '^' expression        { $$ = new Pow( $1, $3 ); }
                ;

 logical        : expression AND expression        { $$ = new And( $1, $3 ); }
                | expression OR expression         { $$ = new Or( $1, $3 ); }
                ;
 
 expression     : '+' expression %prec UPLUS       { $$ = new Pos( $2 ); }
                | '-' expression %prec UMIN        { $$ = new Neg( $2 ); }
                | '!' expression %prec UNOT        { $$ = new Not( $2 ); }
                | comparison
                | arithmetic
                | logical
                | literal
                | '(' expression ')'               { $$ = $2; }
                ;

 literal        : BOOL                             { $$ = $1; }
                | MON                              { $$ = $1; }
                | INT                              { $$ = $1; }
                | STR                              { $$ = $1; }
                | IDENT                            { $$ = $1; }
                ;

 type           : BOOLEAN                          { $$ = $1; }
                | MONEY                            { $$ = $1; }
                | INTEGER                          { $$ = $1; }
                | STRING                           { $$ = $1; }
                ;

%%
    /**
     * Holds the lexer.
     */
    private QLLexer lexer;
    
    /**
     * Holds the parsing result (AST)
     */
    private INode result;
    
    /**
     * Retrieves the generated AST.
     *
     * @return The AST.
     */
    public INode getResult() {
        return result;
    }
    
    /**
     * Sets the lexer.
     *
     * @param lexer
     */
    public QLParser( QLLexer lexer ) { 
        this.lexer = lexer;
    }
    
    /**
     * Output error message.
     *
     * @param msg The error message.
     */
    private void yyerror( String msg ) { 
        System.err.println( msg );
    }