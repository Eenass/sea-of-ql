// Directives section
%package org.uva.sea.ql.parser.jacc
%class QLParser 	// Change the class name from XParser to QLParser
%interface QLTokens // Change the class name from XTokens to QLTokens
%semantic org.uva.sea.ql.ast.ASTNode 
%start top

// Terminal symbol definitions
// Literals
%token <IntegerLiteral> INTEGERLITERAL
%token <StringLiteral>  STRINGLITERAL
%token <BooleanLiteral> BOOLEANLITERAL
%token <Identifier>     IDENTIFIER
// Types
%token INTEGER BOOLEAN STRING
// Operators
%token '*' '/' '+' '-' OR AND NEQ EQ '<' LEQ '>' GEQ '!'
// Reserved keywords
%token FORM IF
// Syntactic symbols
%token ':' '(' ')' '{' '}'

// Operator associativity and presendence dsds 
%left OR
%left AND
%left '>' '<' GEQ LEQ NEQ EQ
%left '+' '-'
%left '*' '/'
%left UMIN UPLUS UNOT

// Nonterminal symbol definitions 
%type <Node>       node
%type <Form>       form
%type <Question>   question
%type <Type>       type
%type <Expression> expression

// Statements that get put after the package declaration in XParser.java
%{
import org.uva.sea.ql.ast.*;
import org.uva.sea.ql.ast.literal.*;
import org.uva.sea.ql.ast.operators.logical.*;
import org.uva.sea.ql.ast.operators.numeric.*;
import org.uva.sea.ql.ast.operators.relational.*;
import org.uva.sea.ql.ast.type.*;
%}

%% // Rules section

// BEGINSECTION: Todo: remove, and replace "%start top" with "%start form"
// This is only to be able to test forms, questions and expressions seperately

top         : node { result = $1; }
            ;

node        : form
            | question
            | expression
            ;

// ENDSECTION
            
form        : FORM IDENTIFIER '{' body '}' { $$ = new Form($2); }
            ;
		
body        : questions
            ;

questions   : question questions
            | question
			;
			
question    : IDENTIFIER ':' STRINGLITERAL type { $$ = new Question($1, $3); }
            ;

type        : INTEGER
            | BOOLEAN
            | STRING
            ;
		
expression	: arithmetic
		    | logical
			| relational
		    | literal
		    | '(' expression ')' { $$ = $2; }
		    ;
		 
arithmetic  : '+' expression %prec UPLUS { $$ = new Pos($2); }
		    | '-' expression %prec UMIN  { $$ = new Neg($2); }
            | expression '*' expression	 { $$ = new Mul($1, $3); }
		    | expression '/' expression  { $$ = new Div($1, $3); }
		    | expression '+' expression  { $$ = new Add($1, $3); }
		    | expression '-' expression	 { $$ = new Sub($1, $3); }
			;

logical     : '!' expression %prec UNOT { $$ = new Not($2); }
			| expression AND expression	{ $$ = new And($1, $3); }
	        | expression OR  expression { $$ = new Or($1, $3); }
			;
			
relational  : expression EQ  expression { $$ = new Eq($1, $3); }
		    | expression NEQ expression { $$ = new NEq($1, $3); }
		    | expression '>' expression	{ $$ = new GT($1, $3); }
		    | expression '<' expression	{ $$ = new LT($1, $3); }
		    | expression GEQ expression	{ $$ = new GEq($1, $3); }
		    | expression LEQ expression	{ $$ = new LEq($1, $3); }
			;

literal     : INTEGERLITERAL { $$ = $1; }
		    | STRINGLITERAL  { $$ = $1; }
		    | BOOLEANLITERAL { $$ = $1; }
		    | IDENTIFIER     { $$ = $1; }
            ;
            
%% // Additional code section

private QLLexer lexer; 

private Node result;

public Node getResult() {
  return result;
}

public QLParser(QLLexer lexer) { 
  this.lexer = lexer; 
}

private void yyerror(String msg) { 
  System.err.println(msg); 
}