// Directives section
%package org.uva.sea.ql.parser.jacc
%class QLParser 	// Change the class name from XParser to QLParser
%interface QLTokens // Change the class name from XTokens to QLTokens
%semantic org.uva.sea.ql.ast.ASTNode 
%start top

// Terminal symbol definitions
// Literals
%token <IntegerLiteral> INTEGERLITERAL
%token <StringLiteral>  STRINGLITERAL
%token <BooleanLiteral> BOOLEANLITERAL
%token <Identifier>     IDENTIFIER
// Types
%token INTEGER BOOLEAN STRING MONEY
// Operators
%token '*' '/' '+' '-' OR AND NEQ EQ '<' LEQ '>' GEQ '!'
// Reserved keywords
%token FORM IF
// Syntactic symbols
%token ':' '(' ')' '{' '}' ';'

// Operator associativity and presendence
%left OR
%left AND
%left '>' '<' GEQ LEQ NEQ EQ
%left '+' '-'
%left '*' '/'
%left UMIN UPLUS UNOT

// Nonterminal symbol definitions 
%type <Node>       node
%type <Form>       form
%type <Type>       type
%type <Expression> expression
%type <IfBlock>    ifblock
%type <Statement>  statement
%type <Statements> statements

// Statements that get put after the package declaration in XParser.java
%{
import org.uva.sea.ql.ast.*;
import org.uva.sea.ql.ast.expression.*;
import org.uva.sea.ql.ast.expression.literal.*;
import org.uva.sea.ql.ast.expression.operators.logical.*;
import org.uva.sea.ql.ast.expression.operators.numeric.*;
import org.uva.sea.ql.ast.expression.operators.relational.*;
import org.uva.sea.ql.ast.statement.*;
import org.uva.sea.ql.ast.type.*;
%}

%% // Rules section

// BEGINSECTION: Todo: remove, and replace "%start top" with "%start form"
// This is only to be able to test forms, questions and expressions seperately

top         : node { result = $1; }
            ;

node        : form
            | statement
            | expression
            ;

// ENDSECTION
            
form        : FORM IDENTIFIER '{' statements '}' { $$ = new Form($2, $4); }
            ;

statements  : statement statements { $$ = new Statements($1, $2); }
            | statement            { $$ = new Statements($1); }
            ;
            
statement   : question
            | ifblock
            ;
			
question    : IDENTIFIER ':' STRINGLITERAL type '(' expression ')' { $$ = new ComputedQuestion($1, $3, $4, $6); }
            | IDENTIFIER ':' STRINGLITERAL type                    { $$ = new Question($1, $3, $4); }
            ;
            
type        : INTEGER { $$ = new Int(); }
            | BOOLEAN { $$ = new Bool(); }
            | STRING  { $$ = new Str(); }
            //| MONEY
            ;

ifblock     : IF '(' expression ')' '{' statements '}' { $$ = new IfBlock($3, $6); }
            ;
            
expression	: arithmetic
		    | logical
			| relational
		    | literal
		    | '(' expression ')' { $$ = $2; }
		    ;
		 
arithmetic  : '+' expression %prec UPLUS { $$ = new Pos($2); }
		    | '-' expression %prec UMIN  { $$ = new Neg($2); }
            | expression '*' expression	 { $$ = new Mul($1, $3); }
		    | expression '/' expression  { $$ = new Div($1, $3); }
		    | expression '+' expression  { $$ = new Add($1, $3); }
		    | expression '-' expression	 { $$ = new Sub($1, $3); }
			;

logical     : '!' expression %prec UNOT { $$ = new Not($2); }
			| expression AND expression	{ $$ = new And($1, $3); }
	        | expression OR  expression { $$ = new Or($1, $3); }
			;
			
relational  : expression EQ  expression { $$ = new Eq($1, $3); }
		    | expression NEQ expression { $$ = new NEq($1, $3); }
		    | expression '>' expression	{ $$ = new GT($1, $3); }
		    | expression '<' expression	{ $$ = new LT($1, $3); }
		    | expression GEQ expression	{ $$ = new GEq($1, $3); }
		    | expression LEQ expression	{ $$ = new LEq($1, $3); }
			;

literal     : INTEGERLITERAL { $$ = $1; }
		    | STRINGLITERAL  { $$ = $1; }
		    | BOOLEANLITERAL { $$ = $1; }
		    | IDENTIFIER     { $$ = $1; }
            ;
            
%% // Additional code section

private QLLexer lexer; 

private Node result;

public Node getResult() {
  return result;
}

public QLParser(QLLexer lexer) { 
  this.lexer = lexer; 
}

private void yyerror(String msg) { 
  System.err.println(msg); 
}