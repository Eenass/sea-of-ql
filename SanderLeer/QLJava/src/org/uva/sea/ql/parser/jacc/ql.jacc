%package org.uva.sea.ql.parser.jacc
%class QLParser
%interface QLTokens
%semantic org.uva.sea.ql.ast.ASTNode 
%start form

%token FORM
%token IF
%token <IntegerType> INTEGER_TYPE
%token <StringType> STRING_TYPE
%token <BooleanType> BOOLEAN_TYPE
%token <IntegerValue> INTEGER
%token <BooleanValue> TRUE FALSE
%token <StringValue> STRING
%token <Identifier> IDENTIFIER
%token '*' '/' '+' '-' OR AND NEQ EQ '<' LEQ '>' GEQ '!'
%token '(' ')' '{' '}' ':' ';'

%left OR
%left AND
%left '>' '<' GEQ LEQ NEQ EQ
%left '+' '-'
%left '*' '/'
%left UMIN UPLUS UNOT

%{
import org.uva.sea.ql.ast.*;
%}

%%
form			: FORM IDENTIFIER '{' statement_list '}'		{ result = new Form($2, $4); }

//TODO: remove before production
 				| expr											{ result = $1; }
 				;
 
statement_list	: statement										{ $$ = new StatementList(); ((StatementList)$$).addStatement($1); }
 				| statement_list statement						{ $$ = $1; ((StatementList)$1).addStatement($2); }
 				;

statement		: question										{ $$ = $1; }
 				| if											{ $$ = $1; }
 				;
  			
question		: IDENTIFIER ':' STRING datatype				{ $$ = new Question($1, $3, (Datatype)$4);
																  if (symbols.contains($1.getName())) {
																    yyerror("Question identifier '" + $1.getName() + "' already defined");
																    // JACC does not seem to support the YYERROR and YYABORT macros
																    return 0;
																  }
																  symbols.put($1.getName(), (Datatype)$4);
																}
 				| IDENTIFIER ':' STRING datatype '(' expr ')'	{ $$ = new ComputedQuestion($1, $3, (Datatype)$4, $6);
																  if (symbols.contains($1.getName())) {
																    yyerror("Question identifier '" + $1.getName() + "' already defined");
																    // JACC does not seem to support the YYERROR and YYABORT macros
																    return 0;
																  }
																  symbols.put($1.getName(), (Datatype)$4);
 																}
 				; 

datatype		: INTEGER_TYPE									{ $$ = new IntegerType(); }
 				| STRING_TYPE									{ $$ = new StringType(); }
 				| BOOLEAN_TYPE									{ $$ = new BooleanType(); }
 				;

if				: IF '(' expr ')' '{' statement_list '}'		{ $$ = new IfStmt($3, $6); }
 				;
 			
expr			: '+' expr %prec UPLUS							{ $$ = new Pos($2); }
				| '-' expr %prec UMIN							{ $$ = new Neg($2); }
				| '!' expr %prec UNOT							{ $$ = new Not($2); }
				| expr '*' expr									{ $$ = new Mul($1, $3); }
				| expr '/' expr									{ $$ = new Div($1, $3); }
				| expr '+' expr									{ $$ = new Add($1, $3); }
				| expr '-' expr									{ $$ = new Sub($1, $3); }
				| expr EQ expr									{ $$ = new Eq($1, $3); }
				| expr NEQ expr									{ $$ = new NEq($1, $3); }
				| expr '>' expr									{ $$ = new GT($1, $3); }
				| expr '<' expr									{ $$ = new LT($1, $3); }
				| expr GEQ expr									{ $$ = new GEq($1, $3); }
				| expr LEQ expr									{ $$ = new LEq($1, $3); }
				| expr AND expr									{ $$ = new And($1, $3); }
		    	| expr OR expr									{ $$ = new Or($1, $3); }
				| TRUE											{ $$ = new BooleanValue(true); }
				| FALSE											{ $$ = new BooleanValue(false); }
				| INTEGER										{ $$ = $1; }
				| STRING										{ $$ = $1; }
				| IDENTIFIER									{ $$ = $1;
																  if (!symbols.contains($1.getName())) {
																    yyerror("Variable '" + $1.getName() + "' not defined");
																    // JACC does not seem to support the YYERROR and YYABORT macros
																    return 0;
																  }
																}
				| '(' expr ')'									{ $$ = $2; }
				;

%%
//TODO: remove before production
private void printNode(String item, ASTNode node) {
	System.out.print("$" + item + " = " + node.getClass() + " (");

	if (node.getClass() == Question.class) {
	  System.out.print(((Question)node).getIdentifier().getName());
	} else if (node.getClass() == StatementList.class) {
	  System.out.print("StatementList");
	} else {
	  System.out.print("something else : " + node.toString());
	}
	
	System.out.println(")");
}

private QLLexer lexer; 
private ASTNode result;
private SymbolTable symbols;

public ASTNode getResult() {
  return result;
}

public QLParser(QLLexer lexer, SymbolTable symbols) { 
  this.lexer = lexer; 
  this.symbols = symbols;
}

private void yyerror(String msg) { 
  System.err.println(msg); 
}