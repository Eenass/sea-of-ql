%package org.uva.sea.ql.parser
%class Parser
%interface Tokens
%semantic org.uva.sea.ql.ast.Node 
%start testexpression

%token <NumberLiteral> NUMBERLITERAL
%token <StringLiteral> STRINGLITERAL
%token <BooleanLiteral> BOOLEANLITERAL
%token <TypeDeclaration> TYPE
%token <Identifier> IDENTIFIER
%token '*' '/' '+' '-' OR AND NEQ EQ '<' LEQ '>' GEQ '!'
%token '(' ')' '{' '}' ';' ':'
%token FORM IF ELSE
%left OR
%left AND
%left EQ NEW '>' '<' GEQ LEQ
%left '+' '-'
%left '*' '/'
%left UMIN UPLUS UNOT

%type <Expression> expression comparison 
%type <Question> question
%type <Statement> statement
%type <Statement> openstatement
%type <Statement> closedstatement
%type <FormDefintion> form
%{
import org.uva.sea.ql.ast.*;
import org.uva.sea.ql.ast.expressions.*;
import org.uva.sea.ql.ast.statements.*;
import org.uva.sea.ql.ast.types.*;
%}

%%

form : FORM STRINGLITERAL statement { $$ = new Form(lexer.location(), $2, $3);  } 
	 ;  
 
testexpression : expression { result = $1; }
               ;
 
statement : openstatement
          | closedstatement
          ;
          
openstatement : IF expression statement { $$ = new If(lexer.location(), $2, $3); }
			  | IF expression closedstatement ELSE openstatement { $$ = new If(lexer.location(), $2, $3, $5); }
			   ;

closedstatement : IF expression closedstatement ELSE closedstatement { $$ = new If(lexer.location(), $2, $3, $5); } 
				| question
                | question question 
                | '{' question '}'
      			;	
      			
question : STRINGLITERAL IDENTIFIER ':' TYPE { $$ = new Question(lexer.location(), $1, $2, $4); }
		 | STRINGLITERAL IDENTIFIER '=' expression { $$ = new Question(lexer.location(), $1, $2, $4); } 
		 | /* empty */
		 ;         
	 
 comparison : expression EQ expression		{ $$ = new Equals(lexer.location(), $1, $3); }
	 		| expression NEQ expression		{ $$ = new NotEquals(lexer.location(), $1, $3); }
		 	| expression '>' expression		{ $$ = new GreaterThan(lexer.location(), $1, $3); }
		 	| expression '<' expression		{ $$ = new LessThan(lexer.location(), $1, $3); }
		 	| expression LEQ expression		{ $$ = new LessThanOrEquals(lexer.location(), $1, $3); }
		 	| expression					{ $$ = $1; }
		 	;

 expression	: '+' expression	%prec UPLUS { $$ = new UnaryPlus(lexer.location(), $2); }
		 	| '-' expression	%prec UMIN  { $$ = new UnaryMinus(lexer.location(), $2); }
		 	| '!' expression 	%prec UNOT  { $$ = new UnaryNot(lexer.location(), $2); }
		 	| expression '*' expression		{ $$ = new Multiplication(lexer.location(), $1, $3); }
		 	| expression '/' expression 	{ $$ = new Division(lexer.location(), $1, $3); }
		 	| expression '+' expression		{ $$ = new Addition(lexer.location(), $1, $3); }
		 	| expression '-' expression		{ $$ = new Subtraction(lexer.location(), $1, $3);}
		 	| expression AND expression	    { $$ = new And(lexer.location(),$1, $3); }
		 	| expression OR expression		{ $$ = new Or(lexer.location(),$1, $3); }
		 	| NUMBERLITERAL					{ $$ = $1; }
		 	| STRINGLITERAL					{ $$ = $1; }
		 	| BOOLEANLITERAL			    { $$ = $1; }
		 	| IDENTIFIER      				{ $$ = $1; }
		 	| '(' expression ')'			{ $$ = $2; }
		    ;
		
  
          
%%
private Lexer lexer; 

private Node result;

public Node getResult() {
  return result;
}

public Parser(Lexer lexer) { 
  this.lexer = lexer; 
}

private void yyerror(String msg) { 
  System.err.println(msg); 
}