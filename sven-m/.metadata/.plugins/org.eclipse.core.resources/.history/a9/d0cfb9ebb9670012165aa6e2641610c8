package org.uva.sea.ql.parser.test;

import static org.junit.Assert.assertEquals;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;
import org.uva.sea.ql.ast.expression.Add;
import org.uva.sea.ql.ast.expression.And;
import org.uva.sea.ql.ast.expression.GT;
import org.uva.sea.ql.ast.expression.Ident;
import org.uva.sea.ql.ast.expression.Int;
import org.uva.sea.ql.ast.expression.LEq;
import org.uva.sea.ql.ast.expression.LT;
import org.uva.sea.ql.ast.expression.Mul;
import org.uva.sea.ql.ast.expression.Not;
import org.uva.sea.ql.ast.form.Body;
import org.uva.sea.ql.ast.form.ComputedQuestion;
import org.uva.sea.ql.ast.form.IfStatement;
import org.uva.sea.ql.ast.form.QLForm;
import org.uva.sea.ql.ast.form.Question;
import org.uva.sea.ql.parser.antlr.QLFormParser;

@RunWith(Parameterized.class)
public class TestSyntax {
	private HashMap<String, Class<?>> tests;

	private IParse parser;

	@Parameters
	public static List<Object[]> theParsers() {
		Object[][] params = { { new QLFormParser() } };
		return Arrays.asList(params);
	}

	public TestSyntax(IParse parser) {
		this.parser = parser;
	}
	
	@Before
	public void initMap() {
		tests = new HashMap<String, Class<?>>();
	}
	
	private void test(String parseMethod) throws ParseError {
		for (Map.Entry<String, Class<?>> t : tests.entrySet()) {
			assertEquals(
				"Error source: " + t.getKey(), // message
				t.getValue(),				   // expected
				parseUsingMethod(parseMethod, t.getKey()).getClass() // actual
			);
		}
	}
	
	private Object parseUsingMethod(String methodName, String src) {
		Method method = null;
		Object result = null;
		
		try {
			 method = parser.getClass().getMethod(methodName, String.class);
			 result = method.invoke(parser, src);
		} catch (NoSuchMethodException e) {
			System.out.println("Tests aborted: Parse method not available");
			System.exit(1);
		} catch (IllegalAccessException e) {
			System.out.println("Tests aborted: Reflection not available");
			System.exit(1);
		} catch (IllegalArgumentException e) {
			System.out.println("Tests aborted: Invalid arguments passed to"
					+ " parse method");
			System.exit(1);
		} catch (InvocationTargetException e) {
			System.out.println("Tests aborted: " + e.getCause().getMessage());
			System.exit(1);
		}
		
		return result;
	}
	
	@Test
	public void TestForms() throws ParseError {
		tests.put("form f1 { q1: \" \" boolean \n }", QLForm.class);
		
		test("parseForm");
	}
	
	@Test
	public void TestBodies() throws ParseError {
		tests.put("{ \n q1: \" \" boolean }", Body.class);
		
		test("parseBody");
	}
	
	@Test
	public void FormElements() throws ParseError {
		tests.put("q1: \" \" boolean", Question.class);
		
		test("parseFormElement");
	}
	
	@Test
	public void testAdds() throws ParseError {
		tests.put("a + b", Add.class);
		tests.put("a + b + c", Add.class);
		tests.put("(a + b + c)", Add.class);
		tests.put("a + (b + c)", Add.class);
		tests.put("(a + b) + c", Add.class);
		tests.put("(a + b)", Add.class);
		tests.put("a + b * c", Add.class);
		tests.put("a * b + c", Add.class);
		
		test("parseExpr");
	}

	@Test
	public void testMuls() throws ParseError {
		tests.put("a * b", Mul.class);
		tests.put("a * b * c", Mul.class);
		tests.put("a * (b * c)", Mul.class);
		tests.put("(a * b) * c", Mul.class);
		tests.put("(a * b)", Mul.class);
		tests.put("(a + b) * c", Mul.class);
		tests.put("a * (b + c)", Mul.class);
		
		test("parseExpr");
	}

	@Test
	public void testRels() throws ParseError {
		tests.put("a < b", LT.class);
		tests.put("a < b + c", LT.class);
		tests.put("a < (b * c)", LT.class);
		tests.put("(a * b) < c", LT.class);
		
		tests.put("(a <= b)", LEq.class);
		
		tests.put("a + b > c", GT.class);
		tests.put("a > b + c", GT.class);
		
		test("parseExpr");
	}

	@Test
	public void testBools() throws ParseError {
		tests.put("!b", Not.class);
		tests.put("a && b", And.class);
		tests.put("a > b && b > c", And.class);
		tests.put("(a > b) && (b > c)", And.class);
		
		test("parseExpr");
	}

	@Test
	public void testIds() throws ParseError {
		tests.put("a", Ident.class);
		tests.put("abc", Ident.class);
		tests.put("ABC", Ident.class);
		tests.put("ABCDEF", Ident.class);
		tests.put("abc2323", Ident.class);
		tests.put("a2bc232", Ident.class);
		tests.put("a2bc232aa", Ident.class);
		
		test("parseExpr");
	}

	@Test
	public void testNums() throws ParseError {
		tests.put("0", Int.class);
		tests.put("1223", Int.class);
		tests.put("234234234", Int.class);
		
		test("parseExpr");
	}

}
