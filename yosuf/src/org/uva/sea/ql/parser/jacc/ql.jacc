%package org.uva.sea.ql.parser.jacc
%class QLParser
%interface QLTokens
%semantic org.uva.sea.ql.ast.ASTNode 
%start top

%token <Int> INT
%token IDENT
%token '*' '/' '+' '-' OR AND NEQ EQ '<' LEQ '>' GEQ '!'
%token '(' ')'
%token IF

%left OR
%left AND
%left '>' '<' GEQ LEQ NEQ EQ
%left '+' '-'
%left '*' '/'
%left UMIN UPLUS UNOT

%type <Expression> expr
%type <CompoundStatement> compound

%{
import org.uva.sea.ql.ast.*;
%}

%%

top 	: expr 		{ exprResult = $1; }
		| compound	{ compoundResult = $1;  }
		;

expr	: '+' expr	%prec UPLUS { $$ = new Positive($2); }
		| '-' expr	%prec UMIN  { $$ = new Negative($2); }
		| '!' expr %prec UNOT  	{ $$ = new Not($2); }
		| expr '*' expr			{ $$ = new Multiply($1, $3); }
		| expr '/' expr 		{ $$ = new Divide($1, $3); }
		| expr '+' expr			{ $$ = new Add($1, $3); }
		| expr '-' expr			{ $$ = new Substitute($1, $3); }
		| expr EQ expr		    { $$ = new Equals($1, $3); }
		| expr NEQ expr			{ $$ = new NotEquals($1, $3); }
		| expr '>' expr			{ $$ = new GreaterThan($1, $3); }
		| expr '<' expr			{ $$ = new SmallerThan($1, $3); }
		| expr GEQ expr			{ $$ = new GreaterOrEquals($1, $3); }
		| expr LEQ expr			{ $$ = new SmallerOrEquals($1, $3); }
		| expr AND expr	   		{ $$ = new And($1, $3); }
	    | expr OR expr  		{ $$ = new Or($1, $3); }
		| INT					{ $$ = $1; }
		| IDENT         		{ $$ = $1; }
		| '(' expr ')'			{ $$ = $2; }
		;

compound: stm					{ $$ = $1; }
		| ifStm					{ $$ = $1; }
		;

stm		: IDENT '=' expr ';'	{ $$ = new Assignment($1, $3); }
		;

ifStm	: IF '(' expr ')' '{' compound '}'		{ $$ = new IfStatement($3, $6); }
		;						

%%

private QLLexer lexer; 
private Expression exprResult;
private CompoundStatement compoundResult;

public CompoundStatement getStatementResult(){
	return compoundResult;
}


public Expression getExprResult() {
  return exprResult;
}

public QLParser(QLLexer lexer) { 
  this.lexer = lexer; 
}

private void yyerror(String msg) { 
  System.err.println(msg); 
}