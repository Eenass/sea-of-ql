%package parser
%class QLParser
%interface QLTokens
%semantic ast.ASTNode 
%start top

%token <ast.expression.value.Int> INT
%token <ast.expression.value.Money> MONEY
%token <ast.expression.value.Bool> BOOL
%token <ast.expression.value.Str> STR
%token <ast.expression.value.Ident> IDENT
%token '*' '/' '+' '-' OR AND NEQ EQ '<' LEQ '>' GEQ '!'
%token '(' ')' '{' '}'
%token TRUE FALSE
%token IF ELSE ELSEIF
%token FORM
%token <ast.type.Bool> tBool
%token <ast.type.Ident> tIdent
%token <ast.type.Int> tInt
%token <ast.type.Money> tMoney
%token <ast.type.Str> tStr

%left OR
%left AND
%left '>' '<' GEQ LEQ NEQ EQ
%left '+' '-'
%left '*' '/'
%left UMIN UPLUS UNOT

%type <ast.Expression> expression
%type <ast.statement.Form> form
%type <ast.Statement> statement
%type <ast.type.Bool> tBool
%type <ast.type.Ident> tIdent
%type <ast.type.Int> tInt
%type <ast.type.Money> tMoney
%type <ast.type.Str> tStr
%type <ast.Type> dType
%type <ast.statement.Else> elseexpr
%type <ast.Statement> ifexpr
%type <ast.statement.Var> dec

%{
import ast.*;
import ast.expression.binary.*;
import ast.expression.unary.*;
import ast.expression.value.*;
import ast.statement.*;
@SuppressWarnings("unused")
%}

%%

top 			: form { result = $1; }
	     		;
	     		
form			: FORM IDENT '{' statement '}'				{ $$ = new Form($2,$4); }
				;
     
statement 		: STR dec									{ $$ = new Question($1,$2); }
				| IDENT '=' expression						{ $$ = new Assignment($1,$3); }
				| dec
				| ifcon
				;
				
dec				: IDENT ':' dType							{ $$ = new Var($1,$3); }
				;
				
ifexpr			: IF '(' expression ')' '{' statement '}'	{ $$ = new If($3,$6); }
				;
				
ifcon			: ifexpr elseexpr
				| ifexpr
				;
				
elseexpr		: ELSE '{' statement '}'					{ $$ = new Else($3); }
				| ELSE ifexpr								{ $$ = new Else($2); }
				;

expression	 	: '+' expression %prec UPLUS 				{ $$ = new Pos($2); }
				| '-' expression %prec UMIN  				{ $$ = new Neg($2); }
				| '!' expression %prec UNOT 				{ $$ = new Not($2); }
				| expression '*' expression					{ $$ = new Mul($1, $3); }
				| expression '/' expression 				{ $$ = new Div($1, $3); }
				| expression '+' expression					{ $$ = new Add($1, $3); }
				| expression '-' expression					{ $$ = new Sub($1, $3); }
				| expression EQ expression			    	{ $$ = new Eq($1, $3); }
				| expression NEQ expression					{ $$ = new NEq($1, $3); }
				| expression '>' expression					{ $$ = new GT($1, $3); }
				| expression '<' expression					{ $$ = new LT($1, $3); }
				| expression GEQ expression					{ $$ = new GEq($1, $3); }
				| expression LEQ expression					{ $$ = new LEq($1, $3); }
				| expression AND expression	    			{ $$ = new And($1, $3); }
			    | expression OR expression  				{ $$ = new Or($1, $3); }
				| '(' expression ')'						{ $$ = $2; }
				| type;
				
type 			: INT										{ $$ = $1; }
				| MONEY										{ $$ = $1; }
				| TRUE										{ $$ = new ast.expression.value.Bool(true); }
				| FALSE										{ $$ = new ast.expression.value.Bool(false); }
				| STR										{ $$ = $1; }
				| IDENT         							{ $$ = $1; }
				;
				
dType			: tBool										{ $$ = new ast.type.Bool(); }
				| tMoney									{ $$ = new ast.type.Money(); }
				| tInt										{ $$ = new ast.type.Int(); }
				| tStr										{ $$ = new ast.type.Str(); }
				;
		 

%%
private QLLexer lexer; 

private Statement result;

public Statement getResult() {
  return result;
}

public QLParser(QLLexer lexer) { 
  this.lexer = lexer; 
}

private void yyerror(String msg) { 
  System.err.println(msg); 
}