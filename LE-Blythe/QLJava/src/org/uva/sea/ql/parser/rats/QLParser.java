// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.3.1,
// (C) 2004-2012 Robert Grimm,
// on donderdag 28 februari 2013 at 21:51:45.
// Edit at your own risk.
// ===========================================================================

package org.uva.sea.ql.parser.rats;

import java.io.Reader;
import java.io.IOException;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import xtc.util.Action;
import org.uva.sea.ql.ast.*;
import org.uva.sea.ql.ast.statement.*;
import org.uva.sea.ql.ast.operative.*;
import org.uva.sea.ql.ast.type.*;
import org.uva.sea.ql.ast.primitive.*;

/**
 * Packrat parser for grammar <code>org.uva.sea.ql.parser.rats.QLParser</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.3.1, (C) 2004-2012 Robert Grimm.
 */
public final class QLParser extends ParserBase {

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fBlock;
    Result fBlock$$Star1;
    Result fExpr;
    Result fRelExpr;
    Result fAddExpr;
    Result fAddExpr$$Star1;
    Result fMulExpr;
    Result fMulExpr$$Star1;
    Result fUnary;
    Result fIdent;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fIdent$$Star1;
    Result fLiteralString;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class QLParserColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public QLParser(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public QLParser(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new QLParserColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.RunParse.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pRunParse(final int yyStart) throws IOException {
    Result     yyResult;
    Form       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pForm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.Form.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pForm(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Form       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pSpacing(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pIdent(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                String f = yyResult.semanticValue();

                yyResult = pSpacing(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pBlock(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Block b = yyResult.semanticValue();

                    yyValue = new Form(f, b);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("form expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.Block.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlock(final int yyStart) throws IOException {
    QLParserColumn yyColumn = (QLParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fBlock) 
      yyColumn.chunk1.fBlock = pBlock$1(yyStart);
    return yyColumn.chunk1.fBlock;
  }

  /** Actually parse org.uva.sea.ql.parser.rats.QLParser.Block. */
  private Result pBlock$1(final int yyStart) throws IOException {
    Result     yyResult;
    Block      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLBracket(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBlock$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Statement> l = yyResult.semanticValue();

        yyResult = pRBracket(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue= new Block(l.list());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.uva.sea.ql.parser.rats.QLParser.Block$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlock$$Star1(final int yyStart) throws IOException {
    QLParserColumn yyColumn = (QLParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fBlock$$Star1) 
      yyColumn.chunk1.fBlock$$Star1 = pBlock$$Star1$1(yyStart);
    return yyColumn.chunk1.fBlock$$Star1;
  }

  /** Actually parse org.uva.sea.ql.parser.rats.QLParser.Block$$Star1. */
  private Result pBlock$$Star1$1(final int yyStart) throws IOException {
    Result          yyResult;
    Pair<Statement> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Statement v$el$1 = yyResult.semanticValue();

      yyResult = pBlock$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Statement> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Statement>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement(final int yyStart) throws IOException {
    Result     yyResult;
    Statement  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIfThen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pQuestion(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.IfThen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIfThen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    IfThen     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pSpacing(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pLParen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr c = yyResult.semanticValue();

              yyResult = pRParen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pBlock(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Block b = yyResult.semanticValue();

                  final int yyChoice1 = yyResult.index;

                  // Nested alternative 1.

                  yyBase = yyChoice1;
                  yyC    = character(yyBase);
                  if ('e' == yyC) {
                    yyIndex = yyChoice1 + 1;

                    yyC = character(yyIndex);
                    if ('l' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('s' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyResult = pSpacing(yyIndex);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pBlock(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Block e = yyResult.semanticValue();

                              yyValue = new IfThenElse(c,b,e);

                              return yyResult.createValue(yyValue, yyError);
                            }
                          }
                        } else {
                          yyError = yyError.select("'else' expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("'else' expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("'else' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("'else' expected", yyBase);
                  }

                  // Nested alternative 2.

                  yyValue = new IfThen(c,b);

                  return new SemanticValue(yyValue, yyChoice1, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("if then expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.Question.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQuestion(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Question   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteralString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String q = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdent(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String x = yyResult.semanticValue();

          yyResult = pSpacing(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if (':' == yyC) {
              yyIndex = yyResult.index + 1;

              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                final int yyChoice1 = yyResult.index;

                // Nested alternative 1.

                yyResult = pType(yyChoice1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Type t = yyResult.semanticValue();

                  yyResult = pSpacing(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = new QuestionAnswerable(q, new Ident(x), t);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }

                // Nested alternative 2.

                yyResult = pExpr(yyChoice1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Expr e = yyResult.semanticValue();

                  yyResult = pSpacing(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = new QuestionComputed(q, new Ident(x), e);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            } else {
              yyError = yyError.select("':' expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'b':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('o' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('o' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('l' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('a' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('n' == yyC) {

                                  yyResult = pSpacing(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyValue = new BoolType();

                                    return yyResult.createValue(yyValue, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'i':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('t' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('g' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('e' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('r' == yyC) {

                                  yyResult = pSpacing(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyValue = new IntType();

                                    return yyResult.createValue(yyValue, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 's':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('t' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('r' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('i' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('n' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('g' == yyC) {

                              yyResult = pSpacing(yyIndex);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyValue = new StrType();

                                return yyResult.createValue(yyValue, yyError);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.Expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpr(final int yyStart) throws IOException {
    QLParserColumn yyColumn = (QLParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExpr) 
      yyColumn.chunk1.fExpr = pExpr$1(yyStart);
    return yyColumn.chunk1.fExpr;
  }

  /** Actually parse org.uva.sea.ql.parser.rats.QLParser.Expr. */
  private Result pExpr$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRelExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr l = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '&':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('&' == yyC) {

                yyResult = pSpacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pRelExpr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Expr r = yyResult.semanticValue();

                    yyValue = new And(l, r);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
          break;

        case '|':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('|' == yyC) {

                yyResult = pSpacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pRelExpr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Expr r = yyResult.semanticValue();

                    yyValue = new Or(l, r);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
    }

    // Alternative 2.

    yyResult = pRelExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.RelExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelExpr(final int yyStart) throws IOException {
    QLParserColumn yyColumn = (QLParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fRelExpr) 
      yyColumn.chunk1.fRelExpr = pRelExpr$1(yyStart);
    return yyColumn.chunk1.fRelExpr;
  }

  /** Actually parse org.uva.sea.ql.parser.rats.QLParser.RelExpr. */
  private Result pRelExpr$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAddExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr l = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '<':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;
              if ('=' == yyC) {

                yyResult = pSpacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pAddExpr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Expr r = yyResult.semanticValue();

                    yyValue = new LEq(l, r);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }

            // Nested alternative 2.

            yyResult = pSpacing(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAddExpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr r = yyResult.semanticValue();

                yyValue = new LT(l, r);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
          break;

        case '>':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;
              if ('=' == yyC) {

                yyResult = pSpacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pAddExpr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Expr r = yyResult.semanticValue();

                    yyValue = new GEq(l, r);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }

            // Nested alternative 2.

            yyResult = pSpacing(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAddExpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr r = yyResult.semanticValue();

                yyValue = new GT(l, r);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
          break;

        case '=':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('=' == yyC) {

                yyResult = pSpacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pAddExpr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Expr r = yyResult.semanticValue();

                    yyValue = new Eq(l, r);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
          break;

        case '!':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('=' == yyC) {

                yyResult = pSpacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pAddExpr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Expr r = yyResult.semanticValue();

                    yyValue = new NEq(l, r);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
    }

    // Alternative 2.

    yyResult = pAddExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("rel expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.AddExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAddExpr(final int yyStart) throws IOException {
    QLParserColumn yyColumn = (QLParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAddExpr) 
      yyColumn.chunk1.fAddExpr = pAddExpr$1(yyStart);
    return yyColumn.chunk1.fAddExpr;
  }

  /** Actually parse org.uva.sea.ql.parser.rats.QLParser.AddExpr. */
  private Result pAddExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMulExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyResult = pAddExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> actions = yyResult.semanticValue();

        yyValue = apply(actions, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.uva.sea.ql.parser.rats.QLParser.AddExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAddExpr$$Star1(final int yyStart) throws IOException {
    QLParserColumn yyColumn = (QLParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAddExpr$$Star1) 
      yyColumn.chunk1.fAddExpr$$Star1 = pAddExpr$$Star1$1(yyStart);
    return yyColumn.chunk1.fAddExpr$$Star1;
  }

  /** Actually parse org.uva.sea.ql.parser.rats.QLParser.AddExpr$$Star1. */
  private Result pAddExpr$$Star1$1(final int yyStart) throws IOException {
    Result             yyResult;
    Pair<Action<Expr>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAddTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expr> v$el$1 = yyResult.semanticValue();

      yyResult = pAddExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.AddTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAddTail(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '+':
        {
          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pMulExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Expr right = yyResult.semanticValue();

              yyValue = new Action<Expr>() {
                public Expr run(Expr left) {
                  return new Add(left, right);
                }
              };

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      case '-':
        {
          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pMulExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Expr right = yyResult.semanticValue();

              yyValue = new Action<Expr>() {
                public Expr run(Expr left) {
                  return new Sub(left, right);
                }
              };

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("add tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.MulExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMulExpr(final int yyStart) throws IOException {
    QLParserColumn yyColumn = (QLParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fMulExpr) 
      yyColumn.chunk1.fMulExpr = pMulExpr$1(yyStart);
    return yyColumn.chunk1.fMulExpr;
  }

  /** Actually parse org.uva.sea.ql.parser.rats.QLParser.MulExpr. */
  private Result pMulExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyResult = pMulExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> actions = yyResult.semanticValue();

        yyValue = apply(actions, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.uva.sea.ql.parser.rats.QLParser.MulExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMulExpr$$Star1(final int yyStart) throws IOException {
    QLParserColumn yyColumn = (QLParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fMulExpr$$Star1) 
      yyColumn.chunk1.fMulExpr$$Star1 = pMulExpr$$Star1$1(yyStart);
    return yyColumn.chunk1.fMulExpr$$Star1;
  }

  /** Actually parse org.uva.sea.ql.parser.rats.QLParser.MulExpr$$Star1. */
  private Result pMulExpr$$Star1$1(final int yyStart) throws IOException {
    Result             yyResult;
    Pair<Action<Expr>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMulTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expr> v$el$1 = yyResult.semanticValue();

      yyResult = pMulExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.MulTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMulTail(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pUnary(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Expr right = yyResult.semanticValue();

              yyValue = new Action<Expr>() {
                public Expr run(Expr left) {
                  return new Mul(left, right);
                }
              };

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      case '/':
        {
          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pUnary(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Expr right = yyResult.semanticValue();

              yyValue = new Action<Expr>() {
                public Expr run(Expr left) {
                  return new Div(left, right);
                }
              };

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("mul tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.Unary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnary(final int yyStart) throws IOException {
    QLParserColumn yyColumn = (QLParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fUnary) 
      yyColumn.chunk1.fUnary = pUnary$1(yyStart);
    return yyColumn.chunk1.fUnary;
  }

  /** Actually parse org.uva.sea.ql.parser.rats.QLParser.Unary. */
  private Result pUnary$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '+':
        {
          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pUnary(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr un = yyResult.semanticValue();

              yyValue = new Pos(un);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      case '-':
        {
          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pUnary(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr un = yyResult.semanticValue();

              yyValue = new Neg(un);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      case '!':
        {
          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pUnary(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr un = yyResult.semanticValue();

              yyValue = new Not(un);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyResult = pPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unary expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.Primary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimary(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteralString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String s = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new Str(s);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 't':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('r' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyResult = pSpacing(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyValue = new Bool(true);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('l' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('s' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyResult = pSpacing(yyIndex);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyValue = new Bool(false);

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyResult = pInt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String n = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new Int(Integer.parseInt(n));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pIdent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String x = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new Ident(x);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 5.

    yyResult = pLParen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pRParen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("primary expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.Int.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInt(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("int expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.Ident.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdent(final int yyStart) throws IOException {
    QLParserColumn yyColumn = (QLParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdent) 
      yyColumn.chunk1.fIdent = pIdent$1(yyStart);
    return yyColumn.chunk1.fIdent;
  }

  /** Actually parse org.uva.sea.ql.parser.rats.QLParser.Ident. */
  private Result pIdent$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pIdent$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("ident expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.uva.sea.ql.parser.rats.QLParser.Ident$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdent$$Star1(final int yyStart) throws IOException {
    QLParserColumn yyColumn = (QLParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fIdent$$Star1) 
      yyColumn.chunk2.fIdent$$Star1 = pIdent$$Star1$1(yyStart);
    return yyColumn.chunk2.fIdent$$Star1;
  }

  /** Actually parse org.uva.sea.ql.parser.rats.QLParser.Ident$$Star1. */
  private Result pIdent$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pIdent$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.LiteralString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteralString(final int yyStart) throws IOException {
    QLParserColumn yyColumn = (QLParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fLiteralString) 
      yyColumn.chunk2.fLiteralString = pLiteralString$1(yyStart);
    return yyColumn.chunk2.fLiteralString;
  }

  /** Actually parse org.uva.sea.ql.parser.rats.QLParser.LiteralString. */
  private Result pLiteralString$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pLiteral(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('\"' == yyC) {
          yyIndex = yyResult.index + 1;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("'\\\"' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("literal string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;
        if ((('\t' <= yyC) && (yyC <= '\n')) ||
            ('\f' == yyC) ||
            ((' ' <= yyC) && (yyC <= '!')) ||
            (('0' <= yyC) && (yyC <= ';')) ||
            ('?' == yyC) ||
            (('A' <= yyC) && (yyC <= 'Z')) ||
            ('_' == yyC) ||
            (('a' <= yyC) && (yyC <= 'z'))) {

          yyRepetition1 = yyIndex;
          continue;
        }
      }
      break;
    }

    yyValue = difference(yyStart, yyRepetition1);

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.LParen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLParen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("l paren expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.RParen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRParen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (')' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("r paren expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.LBracket.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLBracket(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("l bracket expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.RBracket.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRBracket(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('}' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("r bracket expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.uva.sea.ql.parser.rats.QLParser.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    int        yyRepetition2;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }

            // Nested alternative 2.

            yyRepetition1 = yyChoice2;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '/':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('*' == yyC) {

                yyRepetition2 = yyIndex;
                while (true) {

                  final int yyChoice2 = yyRepetition2;

                  // Nested alternative 1.

                  yyC = character(yyChoice2);
                  if (-1 != yyC) {
                    yyIndex = yyChoice2 + 1;

                    switch (yyC) {
                    case '*':
                      {
                        yyPredMatched = false;

                        yyC = character(yyIndex);
                        if ('/' == yyC) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyRepetition2 = yyIndex;
                          continue;
                        } else {
                          yyError = yyError.select("spacing expected", yyStart);
                        }
                      }
                      break;

                    default:
                      {
                        yyRepetition2 = yyIndex;
                        continue;
                      }
                    }
                  }
                  break;
                }

                yyBase = yyRepetition2;
                yyC    = character(yyBase);
                if ('*' == yyC) {
                  yyIndex = yyRepetition2 + 1;

                  yyC = character(yyIndex);
                  if ('/' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyRepetition1 = yyIndex;
                    continue;
                  } else {
                    yyError = yyError.select("'*/' expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("'*/' expected", yyBase);
                }
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

}
